/*! Universal Router | MIT License | https://www.kriasoft.com/universal-router/ */

import pathToRegexp from 'path-to-regexp';

/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright © 2015-present Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

const cache = new Map();

function decodeParam(val) {
  try {
    return decodeURIComponent(val);
  } catch (err) {
    return val;
  }
}

function matchPath(routePath, urlPath, end, parentParams) {
  const key = `${routePath}|${end}`;
  let regexp = cache.get(key);

  if (!regexp) {
    const keys = [];
    regexp = { pattern: pathToRegexp(routePath, keys, { end }), keys };
    cache.set(key, regexp);
  }

  const m = regexp.pattern.exec(urlPath);
  if (!m) {
    return null;
  }

  const path = m[0];
  const params = Object.create(null);

  if (parentParams) {
    Object.assign(params, parentParams);
  }

  for (let i = 1; i < m.length; i += 1) {
    params[regexp.keys[i - 1].name] = m[i] && decodeParam(m[i]);
  }

  return { path: path === '' ? '/' : path, keys: regexp.keys.slice(), params };
}

/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright © 2015-present Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

function matchRoute(route, baseUrl, path, parentParams) {
  let match;
  let childMatches;
  let childIndex = 0;

  return {
    next() {
      if (!match) {
        match = matchPath(route.path, path, !route.children, parentParams);

        if (match) {
          return {
            done: false,
            value: {
              route,
              baseUrl,
              path: match.path,
              keys: match.keys,
              params: match.params
            }
          };
        }
      }

      if (match && route.children) {
        while (childIndex < route.children.length) {
          if (!childMatches) {
            const newPath = path.substr(match.path.length);
            const childRoute = route.children[childIndex];
            childRoute.parent = route;

            childMatches = matchRoute(childRoute, baseUrl + (match.path === '/' ? '' : match.path), newPath.charAt(0) === '/' ? newPath : `/${newPath}`, match.params);
          }

          const childMatch = childMatches.next();
          if (!childMatch.done) {
            return {
              done: false,
              value: childMatch.value
            };
          }

          childMatches = null;
          childIndex += 1;
        }
      }

      return { done: true };
    }
  };
}

/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright © 2015-present Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

function resolveRoute(context, params) {
  if (typeof context.route.action === 'function') {
    return context.route.action(context, params);
  }

  return null;
}

/**
 * Universal Router (https://www.kriasoft.com/universal-router/)
 *
 * Copyright © 2015-present Kriasoft, LLC. All rights reserved.
 *
 * This source code is licensed under the Apache 2.0 license found in the
 * LICENSE.txt file in the root directory of this source tree.
 */

function isChildRoute(parentRoute, childRoute) {
  let route = childRoute;
  while (route) {
    route = route.parent;
    if (route === parentRoute) {
      return true;
    }
  }
  return false;
}

class Router {
  constructor(routes, options = {}) {
    if (Object(routes) !== routes) {
      throw new TypeError('Invalid routes');
    }

    this.baseUrl = options.baseUrl || '';
    this.resolveRoute = options.resolveRoute || resolveRoute;
    this.context = Object.assign({ router: this }, options.context);
    this.root = Array.isArray(routes) ? { path: '/', children: routes, parent: null } : routes;
    this.root.parent = null;
  }

  resolve(pathOrContext) {
    const context = Object.assign({}, this.context, typeof pathOrContext === 'string' ? { path: pathOrContext } : pathOrContext);
    const match = matchRoute(this.root, this.baseUrl, context.path.substr(this.baseUrl.length));
    const resolve = this.resolveRoute;
    let matches = null;
    let nextMatches = null;

    function next(resume, parent = matches.value.route) {
      matches = nextMatches || match.next();
      nextMatches = null;

      if (!resume) {
        if (matches.done || !isChildRoute(parent, matches.value.route)) {
          nextMatches = matches;
          return Promise.resolve(null);
        }
      }

      if (matches.done) {
        return Promise.reject(Object.assign(new Error('Page not found'), { context, status: 404, statusCode: 404 }));
      }

      return Promise.resolve(resolve(Object.assign({}, context, matches.value), matches.value.params)).then(result => {
        if (result !== null && result !== undefined) {
          return result;
        }

        return next(resume, parent);
      });
    }

    context.url = context.path;
    context.next = next;

    return next(true, this.root);
  }
}

Router.pathToRegexp = pathToRegexp;
Router.matchPath = matchPath;
Router.matchRoute = matchRoute;
Router.resolveRoute = resolveRoute;

export default Router;
//# sourceMappingURL=main.mjs.map
